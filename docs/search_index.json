[["index.html", "Syllabus 1 Population Genetics: Simulation and Visualization", " Syllabus November, 2023 1 Population Genetics: Simulation and Visualization Online reference used in AS.360.111. "],["syllabus-population-genetics-simulation-visualization.html", "2 Syllabus: Population Genetics Simulation &amp; Visualization", " 2 Syllabus: Population Genetics Simulation &amp; Visualization Course Number: AS.360.111 Schedule: Fall 2023, Tues 2:30 PM - 4:30 PM Location Homewood Campus, UG Teaching Lab (UTL) 289 Student Hours: Wednesdays 5:30-6:30pm via Zoom; 15 minutes before/after class; by appointment, please email both instructors; Levi 200 or Zoom Instructors: Andrew Bortvin abortvi2@jh.edu Sara Carioscia saracarioscia@jhu.edu 2.0.1 Course Description Dive into the fascinating world of computational evolutionary biology with our course on “Population Genetics Simulation and Visualization.” This hands-on course is designed to equip students with the tools and knowledge needed to understand and analyze complex evolutionary dynamics using the SLiM (Selection, Linkage, and Mutation) simulation software. Through a blend of theoretical lectures and practical sessions, students will learn how to create and manipulate virtual populations, simulate genetic drift, natural selection, and other evolutionary forces. They will gain proficiency in setting up simulation scenarios, running experiments, and collecting raw data. Leveraging this data, students will explore various data visualization techniques to uncover patterns, trends, and insights in the simulated evolutionary processes. Prior programming experience is not required. Students from all departments and at all levels (including first-year undergraduates) are welcome. 2.0.2 Class Structure Class Organization Each class will be divided between lectures covering biological principles, live coding where we teach programming in SLiM, and in-class completion of assignments. As this is a longer class, we will take breaks between sections. Feel free to bring snacks or drinks. Assignments Each day, we will reserve time to work on in-class assignments, which will primarily focus on implementation of simulations and conceptual questions regarding the theory behind population genetics. Assigments will also include additional (optional) questions for students wishing to further develop their models. Please submit all files via email to both instructors. Please save your .slim files as .txt (export and save as) and your resulting plots as .png files. You are welcome to work together in small groups, and collaboration is encouraged. Likewise, we encourage you to seek answers online when encountering. However, please refrain from just copying someone else’s code – you should understand and be able to explain every line of code in your scripts. 2.0.3 Schedule Class Number Date Topics Covered 1 10/31/23 Intro to SLiM + molecular biology 2 11/7/23 Selective Sweeps 3 11/14/23 Multiple Populations 4 11/21/23 Reading in files and visualizing in R (virtual/asynch) 5 11/28/23 Splitting Populations 6 12/5/23 TBD 2.0.4 Grading This course will be graded Satisfactory/Unsatisfactory, and individual assignments will be graded on reasonable completion (rather than accuracy of results). In each assignment, we will specify items to include in your submission; the assignment score will be the fraction of items completed. To achieve a Satisfactory, you must have an average of 70% completion across the assignments. All assignments will be due at the end of the course period. However, please try to submit your work each week - we will look at your work in progress, provide written feedback, discuss any questions or opportunities for improvement, and let you know estimated percent completion. 2.0.5 Student Hours We will host open student hours (time for students to chat about anything! biology, coding, graduate school, materials directly or slightly less directly related to the course, actual assignments) through the end of the semester. In addition to scheduled times above, please email both instructors to schedule a time for either in-person or Zoom. "],["slim-guide.html", "3 SLiM Guide", " 3 SLiM Guide Notes on usage of SLiM for evolutionary modeling. Adapted from the SLiM manual: http://benhaller.com/slim/SLiM_Manual.pdf "],["a-basic-slim-simulation.html", "3.1 A Basic SLiM Simulation", " 3.1 A Basic SLiM Simulation Our first simulation will be a lightly modified version of the script that comes up when we first open the SLiM graphical user interface (GUI). It is a simple simulation tracking one population, with no selection: // set up a simple neutral simulation initialize() { initializeMutationRate(1e-7); // m1 mutation type: neutral initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); // g1 genomic element type: uses m1 for all mutations initializeGenomicElementType(&quot;g1&quot;, m1, 1.0); // uniform chromosome of length 100 kb with uniform recombination initializeGenomicElement(g1, 0, 99999); initializeRecombinationRate(1e-8); } // create a population of 500 individuals 1 early() { sim.addSubpop(&quot;p1&quot;, 500); } 2000 late() { sim.outputFixedMutations(); } "],["initializing-a-simulation.html", "3.2 Initializing a Simulation", " 3.2 Initializing a Simulation The first step in running a simulation is defining all of the parameters that characterize our populations - how many populations are we studying? How big are they? What do individual genomes look like? We use an initialize() block to define any parameters like this. In almost every simulation, we will define a core set of common parameters. They are: 3.2.1 Global Mutation Rates The mutation rate is set by the command initializeMutationRate(). In its simplest form, we run this function with a single argument, the mutation, as such: initializeMutationRate(1e-7);. Now, when executing the simulation, SLiM will go through each gamete base by base, and will introduce a mutation with a probability of 1e-7. 3.2.2 Mutation Types When running our simulation, we can distinguish between multiple kinds of mutations, each with their own prevalence and impact - for example, a neutral substitution, or a lethal deletion, or a rare variant that confers a selective advantage. To create a mutation type, we use the initializeMutationType() command. For example, this following line of code creates a deleterious mutation: initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, -0.02); Let’s break the arguments to initializeMutationType down: the mutation id: this can be any integer, or a string in the format m&lt;integer&gt;. This is the name that you will use to keep track of your mutation. the dominance coefficient: Here, 0.5. This is used when determining how a mutation impacts the fitness of your individual. A mutation with a dominance coefficient of 1.0 is completely dominant; a mutation with a dominance coefficient of 0.0 is recessive. Mutations with values in between represent incomplete dominance - in our case, 0.5 indicates that heterozygotes have half the fitness effect of the mutation the last two arguments, \"f\" and -0.02 denote the distribution and magnitude of how our mutation impacts fitness. f indicates that the effect is fixed - that is, the mutation impacts all affected individuals identically. The value -0.02 indicates that this effect is a fitness reduction of 0.02 - any individual homozygous for this allele is expected to have offspring at 0.98 the frequency of an individual without this allele, all else being equal. While this allele has the same effect on all carriers, we can also create alleles with different fitness effect distributions - for example \"n\" indicates that for each individual with this mutation, we draw the fitness effect from a normal distribution, \"e\" indicates that we draw fitness effects from the exponential distribution. For some of these, e.g. the normal distribution, we may need to provide more than one numerical parameter. 3.2.3 Types of DNA Now that we have defined the types of mutations we can encounter in our simulation, we can no specify the types of genomic regions that we are working with. For example, we can create genomic regions that represent telomeres, centromeres, introns, exons, etc. And intuitively, we can anticipate that mutations are likely to have different effects in different regions (for example, a SNP in an exon is more likely to have a dramatic phenotypic impact than a SNP in a centromere). We can define a type of DNA using the initializeGenomicElementType() function. This function takes three argument, in the following order: the name of the genomic region (in the form \"g\" + an integer) the kinds of mutations that can occur in this type of DNA region. the relative frequencies of different mutation types Here is a simple example of this command: initializeGenomicElementType(\"g1\", m1, 1.0); This creates a type of DNA region called \"g1\", which can only have m1 type mutations. Since there is only one type of mutation, it happens at a frequency of 1. 3.2.4 Genomic Regions Now that we have defined a type of DNA that we can see in our genome, we need to great a specific instance of it. This is done with the initializeGenomicElement() command. This takes as arguments: the type of genomic element the start coordinate the stop coordinate For example: initializeGenomicElement(g1, 0, 99999); This creates a genomic element of type g1, which extends from bases 0 to 99999. 3.2.4.1 Recombination Rates Lastly, we need to set the recombination rate. This is done using the initializeRecombinationRate() function, which functions similarly to how we defined mutation rates. For this function, we just provide a float defining the per base recombination rate: initializeRecombinationRate(1e-8); "],["running-a-simulation.html", "3.3 Running a simulation", " 3.3 Running a simulation Now that we have initialized a simulation, we can define the events that happen during our simulation. Our simulation is organized into generations (used interchangeably with tick cycles), and within each generation, a predefined set of events happen in a fixed order: If you have defined any events as occurring 'early' in a generation, they are executed first Offspring are generated Fixed mutations are removed in the offspring - that is, if all individuals have two copies of a mutation, SLiM stops keeping track of it Parents die, offspring become the new parents If you have defined any events as occurring 'late' in a generation, they are now executed 3.3.1 Adding subpopulations We have used the initialize block to precisely define how the DNA of all of our organisms is structured. Now, we can create a subpopulation. This is conventionally done as an early event in the first generation (that is, this will be the first thing that happens in your simulation). For example: 1 early() { sim.addSubpop(&quot;p1&quot;, 500); } A few things to note here: The first line (1 early()) defines when this event occurs. The 1 indicates that this will happen in the first generation. The early() indicates that this is an early event in the generation (i.e. it happens before generation of offspring) The command sim.addSubpop(\"p1\", 500); creates a subpopulation with the name \"p1\", which contains 500 individuals. 3.3.2 Events that occur every generation The above sim.addSubpop() command was only executed in the first generation. What if we want an event that runs every generation? To do this, we simply create an event without specifying a generation number. For example, let’s say that in each generation, we want to print the list of all mutations that have reached fixation. We can do this with the following command: late() { sim.outputFixedMutations(); } In the first line of this command (late()), we do not specify the generation at which this happens. As a result, it will happen as a late event in every generation. "],["ending-a-simulation.html", "3.4 Ending a simulation", " 3.4 Ending a simulation We can explicitly end a simulation using the command sim.simulationFinished(). 10000 late() { sim.simulationFinished(); } This simply ends the simulation. Typically, we want to output something for the user. We’ll go into more options throughout the course. For now, know that we can output a sample of our population using the following syntax: 10000 late() { p1.outputSample(500); } where 500 is the number of individuals to output from population p1. This outputs a lot of information that is typically sent to a downstream application. A simpler output is to use the function sim.outputFixedMutations(), which outputs a list of all mutations that have reached fixation (are present in two copies in all individuals). 10000 late() { sim.outputFixedMutations(); } "],["multiple-mutations-elements-and-regions.html", "3.5 Multiple Mutations, Elements and Regions", " 3.5 Multiple Mutations, Elements and Regions So far, we have looked at simulations where we only have one mutation type, one genomic element type, and one genomic region. Now, let’s look at how to create multiple mutation types and genomic regions. Here is a simulation that creates three mutation types, each with their own fitness effects initialize(){ initializeMutationRate(1e-7); // Create mutation types initializeMutationType(&quot;m1&quot;, 1.0, &quot;f&quot;, 0.0); // Neutral mutation initializeMutationType(&quot;m2&quot;, 1.0, &quot;f&quot;, 0.02); // favorable mutation initializeMutationType(&quot;m3&quot;, 1.0, &quot;f&quot;, -0.01); // Deleterious mutation // Create Types of DNA initializeGenomicElementType(&quot;g1&quot;, c(m1, m2, m3), c(50, 1, 10)); initializeGenomicElementType(&quot;g2&quot;, m1, 1); // Arrange DNA into a genome initializeGenomicElement(g1, 0, 9999); initializeGenomicElement(g2, 10000, 15000); initializeGenomicElement(g1, 15001, 25000); initializeRecombinationRate(1e-8); } 1 early(){ sim.addSubpop(&quot;p1&quot;, 500); } 10000 early() { sim.outputFixedMutations(); } 3.5.1 Making multiple mutations We can make multiple mutation types using repeated calls to the initializeMutationType() statement. From the script above: initializeMutationType(&quot;m1&quot;, 1.0, &quot;f&quot;, 0.0); // Neutral mutation initializeMutationType(&quot;m2&quot;, 1.0, &quot;f&quot;, 0.02); // favorable mutation initializeMutationType(&quot;m3&quot;, 1.0, &quot;f&quot;, -0.01); // Deleterious mutation Notice that each mutation type has its own name. The three mutations represent neutral, favorable, and deleterious mutations, respectively. These effects are controlled by the fourth argument (0.0, 0.0, -0.01). 3.5.2 Genomic Elements with multiple mutations We can create a genomic element with multiple mutation types. Consider the line below: initializeGenomicElementType(\"g1\", c(m1, m2, m3), c(50, 1, 10)); Notice that for the mutation type, we can provide multiple mutation types using the syntax: c(m1, m2, m3). Likewise, we now set the ratio of how often they appear in the third argument, c(50, 1, 10). This essentially says that: Genomic element \"g1\" can have mutations of type m1, m2, and m3 The chance of an m1 mutation is 50/61. The chance of an m2 mutation is 1/61. The chance of an m3 mutation is 10/61. Note that the order of mutation types within c(m1, m2, m3) is arbitrary, but it needs to match the order of their frequencies in c(50, 1, 10). The following two lines would work identically: initializeGenomicElementType(\"g1\", c(m1, m2, m3), c(50, 1, 10)); initializeGenomicElementType(\"g1\", c(m3, m1, m2), c(10, 50, 1)); 3.5.3 Multiple Genomic Elements Types We can create multiple genomic element types with multiple uses of initializeGenomicElementType(). From the script above: initializeGenomicElementType(&quot;g1&quot;, c(m1, m2, m3), c(50, 1, 10)); initializeGenomicElementType(&quot;g2&quot;, m1, 1); Note that \"g2\" type genomic elements can only have mutations of type m1, despite multiple mutation types being defined. 3.5.4 Multiple Genomic Elements Now that we have defined multiple genomic element types, we can initialize multiple genomic elements with repeated uses of initializeGenomicElement(): initializeGenomicElement(g1, 0, 9999); initializeGenomicElement(g2, 10000, 15000); initializeGenomicElement(g1, 15001, 25000); This creates a genome consisting of a stretch of 10,000 base long stretch of g1-type DNA, a 5,000 base long stretch of g2-type DNA, and a second 10,000 base stretch of g1-type DNA again. To summarize: We have defined three types of mutations with three different fitness effects We have defined two types of DNA. One of them can have mutations of type m1, m2, and m3. The other can only have mutations of type m1 We have arranged the two types of DNA into a genome, in the order g1, g2, g1 3.5.5 SLiM GUI A few interesting things to note about the SLiM GUI in this simulation: Looking at the genomic region viewer, it is now color-coded to reflect the arrangement of multiple genomic regions of different types (dark and light blue). Looking at the mutation tracker, we can see different mutation types color-coded by their fitness effects - yellow for neutral mutations, green for favorable mutations, and red for deleterious mutations. Note that in the dark blue region (g2), there are only neutral mutations. This agrees with our setup of the genome, as g2 can only have mutations of type m1. "],["week-1-assignment.html", "3.6 Week 1 Assignment", " 3.6 Week 1 Assignment 3.6.1 1.1 - Population Size A key concept in population genetics is genetic drift, or the random fluctuation of allele frequencies from generation to generation. In our neutral simulations, genetic drift is the only force that causes alleles to become more or less common with each generation. The extent that genetic drift can influence allele frequencies is dependent on the population size. We can use our neutral simulation to look further investigate this relationship. Pick a range of population sizes, and run your simulation at least 5 times for each population size. Record the number of fixed mutations for each population size. Briefly comment on how the population size is related to the time to fixation. 3.6.2 1.2 - Selection So far, we focused on simulations where all mutations were neutral. Change the selection coefficient of your mutations. Try making your mutation slightly favorable. How does the number of fixed mutations change when you add favorable mutations? How low a selection coefficient do you need for the effect to be visible? Do the same with a slightly deleterious mutation. 3.6.3 1.3 - Multiple mutation types; multiple genomic regions Create two mutation types, one of which is highly (perhaps a selection coefficient around ~0.05) and one of which is deleterious (selection coefficient ~-0.01). Create a genomic region with both of these mutation types. Recall that we can use the syntax c(m1, m2) to provide multiple items together to an argument. For example, we can initialize a genomic element type with two mutation types at relative frequencies of 0.2 and 0.8 as such: initializeGenomicElementType(\"g2\", c(m1, m2), c(0.2, 0.8));. Run this a few times and look to see if your deleterious mutation ever reaches fixation. How could you explain this behavior? Does it still happen if you raise your recombination rate higher (e.g. a biologically unrealistic value of 1e-2)? Why or why not? Note that the following code block will print the number of fixed mutations of type m2: 2000 late() { print(&#39;Number of type 2 fixed mutations:&#39;); print(sum(sim.substitutions.mutationType == m2)); } "],["storing-information.html", "3.7 Storing Information", " 3.7 Storing Information In SLiM, we have many different ways of storing information. The optimal way of storing information depends on two questions: How long do I need to retain this information? Will I need to modify this information? 3.7.1 Local variables Local variables are temporary and mutable. We can define a local variable using the = operator. For example, in the following lines, I save the current number of chromosomes in my population to a variable nChr and the print it to screen: 400 late(){ nChr = size(p1.genomes); // Define number of chromosomes print(nChr); } We can redefine a local variable using the = operator. For example, here we refined nChr to be 3 times nChr: 400 late(){ nChr = size(p1.genomes); // Define number of chromosomes nChr = nChr * 3; // Multiply by 3 and store value print(nChr); } One key feature of local variables is that once you leave the event your are in, local variables are removed from memory. (Recall that an event is considered anything surrounded by curly braces {}). Consider the following example: 400 late(){ nChr = size(p1.genomes); // Define number of chromosomes nChr = nChr * 3; // Multiply by 3 and store value } 400 late() { print(nChr); // This will cause an error } Running the above code will generate an error. In the first 400 late() event we define nChr and update it’s value to be 3 times itself. In the second 400 late() event, we try to print nChr, but after the first event was run, nChr was deleted and no longer exists. This therefore causes an error. Having = define local variables is a somewhat quirky, SLiM-specific behavior. 3.7.2 Constants Constants are permanent and immutable. Once a constant is defined, it will remain in memory for the remainder of the simulation, but we will not be able to change its value. We can create constants using the defineConstant() function. This function takes two arguments - the name of our constant, and it’s value. For example imagine, that we are running multiple iterations of a simulation, and we want to keep track of the trial number. A constant is a good data type to use here, because the trial number will not change within a simulation. 1 early(){ defineConstant(&#39;trialNumber&#39;, 4); } 1 early(){ print(trialNumber); } This works! A constant is saved for the entirety of your simulation, beyond the current event. Note that we can not modify the value of a constant. The following results in an error: 1 early(){ defineConstant(&#39;trialNumber&#39;, 4); trialNumber = trialNumber + 1; } 3.7.3 Simulation Values After the simulation is initialized, we can use the name sim to refer to the entire simulation. We can also attach values to this simulation; each value is permanent and mutable. We can define a new value using the function: sim.setValue(). The syntax for this function is identical to defineConstant() - we provide a name and associated value. We can refer to an existing simulation value using the function sim.getValue(), which just takes the name of your value. For example, in the code below, we define and print a new value initially set to 0 at generation 400. 400 early(){ sim.setValue(&quot;counter&quot;, 0); // define counter to be 0 print(sim.getValue(&quot;counter&quot;)); } Now, in the following event, we update the counter by adding 1 to it in every generation between generations 401 and 500. 401:500 early(){ currentGen = sim.getValue(&quot;counter&quot;); // get the current value of counter sim.setValue(&quot;counter&quot;, currentGen + 1); // increment the counter by 1 print(sim.getValue(&quot;counter&quot;)); // print current value of counter } Note that prior to updating counter, we first set a local variable, currentGen equal to the value of counter. This makes the code more readable, but is not necessary; a more concise form of the above event is: 401:500 early(){ sim.setValue(&quot;counter&quot;, sim.getValue(&quot;counter&quot;) + 1); // increment the counter by 1 print(sim.getValue(&quot;counter&quot;)); // print current value of counter } This functions identically and is one line shorter, at the cost of a more confusing call to sim.setValue(). "],["introducing-sweep-mutations.html", "3.8 Introducing Sweep Mutations", " 3.8 Introducing Sweep Mutations This week, we are simulating selective sweeps, or events in which a genetic variant rises rapidly in frequency due to positive selection. We want to mimic a so-called “soft sweep”, or a scenario in which an existing genetic variant becomes favorable (e.g. because of changing environmental pressures). In practice, a simple way of doing this is to randomly introduce a favorable mutation at a set frequency at a pre-specified generation. This process can be divided into a few sequential steps: Define the mutation type for your sweep At a given generation, sample a predetermined of your individuals To sampled individuals, add the mutation at a predetermined genomic position 3.8.1 Defining the Mutation Let’s start with a familiar initialize statement, where we have one neutral mutation type and one genomic region. initialize(){ initializeMutationRate(1e-7); // Create mutation types initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); // Create Types of DNA initializeGenomicElementType(&quot;g1&quot;, m1, 1); // Arrange DNA into a genome initializeGenomicElement(g1, 0, 9999); initializeRecombinationRate(1e-8); } To introduce our favorable mutation, let’s add the following to our initialize statement: initializeMutationType(\"m2\", 0.5, \"f\", 0.015); m2.mutationStackPolicy=\"l\"; m2.convertToSubstitution = F; The first line should be familiar - we have a mutation type called \"m2\", which has a positive fitness effect of 0.015. The second line, m2.mutationStackPolicy=\"l\"; controls what happens when multiple mutations occur at the same position. By default, SLiM allows multiple mutations at the same position, with additive fitness effects. Since we are modeling a single base substitution, we want to only track the most recent mutation at a given position. setting the mutation stack policy to \"l\" tells SLiM to only care about the last mutation at a given site. The final line, m2.convertToSubstitution = F;, controls how our mutation behaves when it reaches fixation. By default, once a mutation reaches fixation, it is converted to a substitution - that is, SLiM stops tracking the mutation and only keeps a log of the coordinate where the mutation happened. This is because once the variant is fixed, it has the same impact on all individuals. Here, we want to disable this behavior, since we want to track this specific variant throughout the entire simulation. 3.8.2 Sampling individuals Let’s say that we want to introduce this mutation into our population with an allele frequency of 5%, at position 1000. The following code block does this. 400 late(){ p1_size = size(p1.genomes); // Count how many chromosomes we have initial_freq = asInteger(p1_size * 0.05); // Find 5% of total number of chromosomes target = sample(p1.genomes, initial_freq); // Randomly sample 5% of chromosomes target.addNewDrawnMutation(m2, 1000); // Add new mutation } Let’s break this down line by line: p1_size = size(p1.genomes);: p1.genomes is a list of all the chromosomes in our population. The size() function gets the length of this list, i.e. the total number of chromosomes. We save this as a local variable, p1_size. initial_freq = asInteger(p1_size * 0.05);. We multiply our number of chromosomes by 0.05 to get the number of chromosomes into which we want to insert the mutation. Depending on our population size, we might get a non-integer number. Since we can’t add a mutation into, say, 3.2 chromosomes, we convert to an integer, rounding down, using the asInteger() function. target = sample(p1.genomes, initial_freq); The sample() function randomly samples from a set of items. It takes two arguments - what we are sampling from and how many items to sample. This essentially says, we should sample 5% of our genomes. target.addNewDrawnMutation(m2, 1000);: The addNewDrawnMutation() function takes two arguments, the mutation type to add, and the genomic position to add it to. Note that we call the function as target.addNewDrawnMutation() - the target here indicates the object we are operating on. All together, our simulation may look like this: initialize(){ initializeMutationRate(1e-7); // Create mutation types initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); initializeMutationType(&quot;m2&quot;, 1, &quot;f&quot;, 0.015); m2.mutationStackPolicy=&quot;l&quot;; m2.convertToSubstitution = F; // Create Types of DNA initializeGenomicElementType(&quot;g1&quot;, m1, 1); // Arrange DNA into a genome initializeGenomicElement(g1, 0, 9999); initializeRecombinationRate(1e-8); } 1 early(){ sim.addSubpop(&quot;p1&quot;, 500); } 400 late(){ p1_size = size(p1.genomes); // Count how many chromosomes we have initial_freq = asInteger(p1_size * 0.05); // Find 5% of total number of chromosomes target = sample(p1.genomes, initial_freq); // Randomly sample 5% of chromosomes target.addNewDrawnMutation(m2, 1000); // Add new mutation } 2000 late() { sim.outputFixedMutations(); } "],["writing-output.html", "3.9 Writing Output", " 3.9 Writing Output So far, we have used SLiM’s built-in functions to write output. Often, we will want to have a bit more control over our output. The function used to write to a file in SLiM is writeFile(). We will always give writeFile() two arguments - the name of the file we want to write to, and the content we want to write. We typically will also provide the argument append = T or append = F. If append is False, then when we write to a file, we erase any existing contents in that file. If append is True, then then when we write to the file, we keep any existing contents and just add another line at the end. For the sweep that we’ve introduced above, let’s say we want to run a few iterations of our simulation and save the following information: Number of generations since m2 was introduced Current allele frequency of m2 The trial number We can save this in the format: Generation, Allele.Frequency, Trial 0,50,2 1,57,2 2,55,2 3,47,2 Here is a version of our script from the previous page, modified to write the above information to file: initialize(){ initializeMutationRate(1e-7); // Create mutation type initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); initializeMutationType(&quot;m2&quot;, 1, &quot;f&quot;, 0.2); m2.convertToSubstitution = F; m1.convertToSubstitution = F; // Create Types of DNA initializeGenomicElementType(&quot;g1&quot;, m1, 1); // Arrange DNA into a genome initializeGenomicElement(g1, 0, 3000); initializeRecombinationRate(1e-4); defineConstant(&#39;trialNumber&#39;, 1); initializeSex(&quot;A&quot;); } 1 early(){ sim.addSubpop(&quot;p1&quot;, 5000); } 300 late(){ // Initialize generation counter sim.setValue(&quot;generationCount&quot;, 0); // Introduce sweep mutation at 5% allele frequency p1_size = size(p1.genomes); initial_freq = asInteger(p1_size * 0.05); target = sample(p1.genomes, initial_freq); target.addNewDrawnMutation(m2, 1000); // Write the header for your file line = &quot;Generation, Allele.Frequency, Trial&quot;; // Get a file name // this is standard syntax for Mac; see below for non-Mac systems defineConstant(&quot;fname&quot;, paste(&quot;~/slim/AF_trial&quot;, trialNumber, &quot;.csv&quot;, sep =&quot;&quot;)); // Write to file writeFile(fname, line, append=F); } 300:1000 late(){ gen = sim.getValue(&quot;generationCount&quot;); // Count number of m2 mutations m2_count = sum(p1.genomes.countOfMutationsOfType(m2)); // Write data to file line = paste(gen, m2_count, trialNumber, sep = &quot;,&quot;); writeFile(fname, line, append=T); // Update generation counter sim.setValue(&quot;generationCount&quot;, gen + 1); } 1000 late() { print(&#39;Number of fixed mutations:&#39;); print(length(sim.substitutions)); sim.simulationFinished(); } Let’s break down the additions: In the initialize statement, we add the following line: defineConstant('trialNumber', 1); This sets the trial number as a constant (persists throughout the simulation, cannot be modified) equal to 1. In the code block at generation 300 where we add the sweep mutation, we add the following lines of code // Initialize generation counter sim.setValue(&quot;generationCount&quot;, 0); This initializes a generation counter and sets it equal to 0. Because this is saved as a simulation value, we will be able to update the value of our counter throughout the simulation . This will be the leftmost column of our output. * In the code block at generation 300 where we add the sweep mutation, we add the following lines of code: // Write the header for your file line = &quot;Generation, Allele.Frequency, Trial&quot;; // Get a file name defineConstant(&quot;fname&quot;, paste(&quot;~/AF_trial&quot;, trialNumber, &quot;.csv&quot;, sep =&quot;&quot;)); // Write to file writeFile(fname, line, append=F); Here, we define the local variable line to be the text of the first line of our file. Next, we define a constant containing our output file name. To do this, we use the paste() function - this function takes as input a set of variables and combines them together, separating them by the characters provided in the argument sep =\"\". For example, the above paste command produces the filename \"~/AF_trial1.csv\". Finally, we write to file. Because we do want this line to be the first line of our file, we do not append. For non-Mac users, the syntax \"~/directory/filename\" won’t work. Instead, you’ll need to specify the exact path to where you want the file, starting with the system path (e.g., C for computer, D for downloads, etc. depending on your system). In the above example, everything would be the same, but you’d replace the defineConstant line with defineConstant(\"fname\", paste(\"C:/Users/[user]/Downloads/AF_trial\", trialNumber, \".csv\", sep=\"\"));. The “user” should be accessible via your system; for me, it’s firstnamelastname. You can also create a folder (titled “popsims”) within Downloads (or whatever directory you choose) to host the files from this class. In that case, your line would be defineConstant(\"fname\", paste(\"C:/Users/[user]/Downloads/popsims/AF_trial\", trialNumber, \".csv\", sep=\"\"));. This syntax will be the same for writing files in SLiM; just choose a filepath and folder that you’ll be able to access so you can view your output files and use them downstream in visualizations. We’ve added the following code block: 300:1000 late(){ gen = sim.getValue(&quot;generationCount&quot;); // Count number of m2 mutations m2_count = sum(p1.genomes.countOfMutationsOfType(m2)); // Write data to file line = paste(gen, m2_count, trialNumber, sep = &quot;,&quot;); writeFile(fname, line, append=T); // Update generation counter sim.setValue(&quot;generationCount&quot;, gen + 1); } Here, we access the m2 mutations using the syntax: p1.genomes.countOfMutationsOfType(m2). Then, we paste together the number of generations since m2 was introduced, the current m2 count, and the trial number, this time separating our entries by commas. We add this line to the end our file (by appending). Finally, we take our generation counter and raise it by one. "],["code-from-week-2.html", "3.10 Code from Week 2", " 3.10 Code from Week 2 Here is the final simulation developed in class: initialize(){ initializeMutationRate(1e-7); // Create mutation types initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); // neutral mutation initializeMutationType(&quot;m2&quot;, 1, &quot;f&quot;, 0.03); m2.convertToSubstitution = F; // Continue tracking m2 after it reaches fixation m2.mutationStackPolicy=&quot;l&quot;; // If multiple mutations at m2 in a single genome, only care about the last one // Create Types of DNA initializeGenomicElementType(&quot;g1&quot;, m1, 1); // Arrange DNA into a genome initializeGenomicElement(g1, 0, 3000); initializeRecombinationRate(1e-8); defineConstant(&#39;trialNumber&#39;, 1); // Used for construction of file name and in the trial column initializeSex(&quot;A&quot;); // Track sexes of individuals and allow random mating } 1 early(){ sim.addSubpop(&quot;p1&quot;, 500); } 400 late(){ sim.setValue(&quot;counter&quot;, 0); // initialize counter to keep track of generations // Manually introduce mutations // Find how many genomes to add m2 to p1_size = size(p1.genomes); starting_allele_freq = 0.05; initial_freq = asInteger(p1_size * starting_allele_freq); // sample genomes target = sample(p1.genomes, initial_freq); // add m2 target.addNewDrawnMutation(m2, 1000); // Start writing to file line = &quot;Generation, Allele.Frequency, Trial&quot;; defineConstant(&quot;fname&quot;, paste(&quot;~/AF_trial&quot;, trialNumber, &quot;.csv&quot;, sep =&quot;&quot;)); // File path will be different for Windows users writeFile(fname, line, append=F); } 400:2000 late(){ gen = sim.getValue(&quot;counter&quot;); // get current generation m2_count = sum(p1.genomes.countOfMutationsOfType(m2)); // count number of occurences of m2 // write line to end of file line = paste(gen, m2_count, trialNumber, sep = &quot;,&quot;); writeFile(fname, line, append=T); // increment counter bt 1 sim.setValue(&quot;counter&quot;, gen + 1); } 2000 late() { // End simulation print(&#39;Number of fixed mutations:&#39;); print(length(sim.substitutions)); sim.simulationFinished(); } "],["week-2-assignment.html", "3.11 Week 2 Assignment", " 3.11 Week 2 Assignment 3.11.1 Hard Sweeps Starting with the code written in class today, the goal of your work will be to explore hard sweeps. While hard sweeps do occur in nature, they are less common than biologists expected in the past. This assignment will build up some intuition behind why hard sweeps are rare and why they leave such dramatic marks on the genome when they do occur. Start with the following initialize statement and early events: initialize(){ // Start with a high recombination rate initializeMutationRate(1e-3); // Create mutation types initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); initializeMutationType(&quot;m2&quot;, 1, &quot;f&quot;, 0.03); // favorable mutation m2.convertToSubstitution = F;// Continue tracking m2 after it reaches fixation m1.convertToSubstitution = F; m2.mutationStackPolicy=&quot;l&quot;; // If multiple mutations at m2 in a single genome, only care about the last one // Create Types of DNA initializeGenomicElementType(&quot;g1&quot;, m1, 1); // Arrange DNA into a genome initializeGenomicElement(g1, 0, 3000); initializeRecombinationRate(1e-8); initializeSex(&quot;A&quot;); // allow sex in this simulation } 1 early(){ sim.addSubpop(&quot;p1&quot;, 5000); } 200 early() { // After the burn-in period, lower mutation rate to more accurate value sim.chromosome.setMutationRate(1e-7); } This mutation initializes a genome that only has neutral mutations of type m1. We start with a high mutation rate and allow mutations to accumulate for 200 generations before lowering the mutation rate. Please do the following: At generation 400, introduce one instance of mutation type m2. Randomly sample 1 chromosome and add m2 somewhere towards the center of the genome. Remember to do this as a late event! Run your simulation a few times. Do you ever see m2 reach fixation? Does the allele frequency of m2 always immediately go down to 0?. One way to make a selective sweep more likely is to raise the selection coefficient of m2. How high do you have to raise it to observe a sweep? As we did in class, write the allele frequency over time to a file, in the following format: Generation, Allele.Frequency, Trial 0,50,2 1,57,2 2,55,2 3,47,2 Please submit this file along with your assignment. Currently, m2 is dominant. Try making it recessive by changing the dominance coefficient to 0. Observe the results and briefly comment on how often you expect recessive mutations to undergo a hard sweep 3.11.2 Advanced Exercises The following exercises are optional, but explore some really interesting features of simulating selective sweeps. The code here is not more complicated than in the exercises above, but introduces a couple new concepts. 3.11.3 Advanced Exercise 1 - Hard Sweeps, Recombination, and Hitchhiker mutations. In the above exercises, you likely observed that when m2 rises to fixation, it caries with it hitchhiker mutations along the entire chromosome. In reality, linkage is broken down by recombination. Try raising the recombination rate to see if you can observe a decrease in hitchhiker mutations as you move away from the site of m2. This will also be more obvious if you make your chromosome larger. Note that higher recombination rates, higher mutation rates, and larger chromosomes all slow down your simulation. If you make a bigger chromosome and things run slowly, feel free to shorten the burn-in period and decrease the mutation rate in the burn-in period. 3.11.4 Advanced Exercise 2 - Soft Sweeps and Burts of Environmental Pressure Soft sweeps acting on standing variation are often caused by changes in environmental pressures. Sometimes these changes are permanent - for example, migration into a new environment. Often, however, they are transient - e.g. a disease, or a drought. Let’s model a temporary change in environmental conditions Start with the soft sweep simulation developed in class (also available here). Add in the following event: 320 late() { mut = sim.mutationsOfType(m2); mut.setSelectionCoeff(0.0); } This uses the mut.setSelectionCoeff() function to change the selection coefficient of m2 mutations to 0 - making them neutral. Run your simulation and observe the trajectory of m2 - does it still reach fixation? Try adjusting the length of the burst of selection (by changing the above event to not occur in generation 320) and the initial selection coefficient of m2. "],["multiple-populations.html", "3.12 Multiple Populations", " 3.12 Multiple Populations So far, we have only looked at simulations that involve one population. Adding multiple populations that interact with each other requires only a few additions to our code. SLiM has a great way of visualizing your populations, accessed through the following menu: 3.12.1 Adding a new population In past simulations, we’ve added a single population using the command sim.addSubpop();. To add multiple subpopulations, simply use the command multiple times, creating multiple populations with different names. 1 early() { sim.addSubpop(&quot;p1&quot;, 500); sim.addSubpop(&quot;p2&quot;, 3000); } Looking at our population viewer, we can see that there are now two populations displayed. The size of the circles in the viewer is proportionate to the size of the subpopulations that they represent. 3.12.2 Migration between populations To set migration in SLiM, we can use &lt;destination population&gt;.setMigrationRates(&lt;source population&gt;, &lt;rate&gt;). An example of this function is: p1.setMigrationRates(p2, 0.2); The first population here, p1, is the population into which we migrate. The population in the parentheses is the population from which we migrate. The final number is the migration rate. Adding migration to our simulation: 1 early() { sim.addSubpop(&quot;p1&quot;, 500); sim.addSubpop(&quot;p2&quot;, 3000); p1.setMigrationRates(p2, 0.2); } Looking at our population visualization, we can see migration represented by an arrow: If we add reverse migration, we can see that the size of the arrow is proportionate to the migration rate 1 early() { sim.addSubpop(&quot;p1&quot;, 500); sim.addSubpop(&quot;p2&quot;, 3000); p1.setMigrationRates(p2, 0.2); p2.setMigrationRates(p1, 0.8); } Note that we can use multiple calls of setMigrationRates() to change the migration rate throughout our simulation, as such: 1 early() { sim.addSubpop(&quot;p1&quot;, 500); sim.addSubpop(&quot;p2&quot;, 3000); p1.setMigrationRates(p2, 0.2); } 15 early() { p1.setMigrationRates(p2, 0.4); } 3.12.3 Splitting a population into two Real biological populations have common origins, rather than originating independently. We can incorporate this into our SLiM simulations by creating a new population as an offshoot of an existing population. This is accomplished with the function sim.addSubpopSplit(&lt;new pop name&gt;, &lt;new pop size&gt;, &lt;source pop&gt;) For example, we can initialize a population with 500 individuals as such: 1 early() { sim.addSubpop(&quot;p1&quot;, 500); } Our population viewer looks like this: We can add a population split as such: 300 early() { sim.addSubpopSplit(&quot;p2&quot;, 200, p1); p2.setMigrationRates(p1, 0.1); p1.setMigrationRates(p2, 0.04); } Here we create a population p2, derived from population p1 with 200 individuals. We subsequently set weak migration rates between the populations. Our population viewer now looks like this: "],["code-from-week-3.html", "3.13 Code from Week 3", " 3.13 Code from Week 3 Here is the final simulation developed in class: // set up a simple neutral simulation initialize() { initializeMutationRate(1e-7); // m1 mutation type: neutral initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); // g1 genomic element type: uses m1 for all mutations initializeGenomicElementType(&quot;g1&quot;, m1, 1.0); // uniform chromosome of length 100 kb with uniform recombination initializeGenomicElement(g1, 0, 99999); initializeRecombinationRate(1e-8); } // create a population of 500 individuals 1 early() { sim.addSubpop(&quot;p1&quot;, 500); sim.addSubpop(&quot;p2&quot;, 3000); } // allow migration from p1 to p2 100 early() { p2.setMigrationRates(p1, 0.2); } // allow migration from p2 to p1 200 early() { p1.setMigrationRates(p2, 0.5); } // stop allowing migration from p2 to p1 300 early() { p1.setMigrationRates(p2, 0); } // view these dynamics by clicking the bar chart button on the right and then &quot;Graph Population Visualization&quot; // create a new population // allow to migrate into both p1 and p2 // don&#39;t receive any migration 400 early() { sim.addSubpop(&quot;p3&quot;, 3000); p2.setMigrationRates(c(p1, p3), c(0.2,0.1)); //allow migration from p1 and p3 into p2 p1.setMigrationRates(p3, 0.25); } // output samples of 10 genomes periodically, all fixed mutations at end 1000 late() { p1.outputSample(10); } 2000 late() { p1.outputSample(10); } 2000 late() { sim.outputFixedMutations(); } "],["week-3-assignment.html", "3.14 Week 3 Assignment", " 3.14 Week 3 Assignment 3.14.1 Multiple Populations - Graphic The goal of your work this week will be to explore migration between different populations. Start with an initialize statement and early events (either based on code from class, the default SLiM recipe, or a situation of your own design). Try to recreate in SLiM the following population dynamics. Remember that to visualize your populations, click the bar chart emoji on the right (above the output) and then click “Graph Population Visualization.” If you’re able to recreate these graphics, great! Just drop us an email saying you did it and let us know if you have any questions or comments. If you can’t get it to work, send us your SLiM code and some specific questions/pain points and we’ll address it with you via email. Use relatively small population sizes for each (e.g., 500, 2000, 5000) to help the simulations run quickly. You can slow down the appearance of the simulation using the time-bar on the top right of your SLiM window. Example 1 Example 2 Example 3 Example 4 3.14.2 Multiple Populations - Real World Try to develop SLiM code to investigate the following real-world situations. Feel free to use comments in your code to detail each step. Email us with your resulting SLiM code (preferably saved as a .txt file) and let us know if this went well or if you struggled with any code or concept. Stickleback Fish There are two populations of a fish species - one at the top of a river and one at the bottom. Develop a model that allows for some migration between the two populations, with the knowledge that more fish swim downriver (i.e., with the current) than upriver. Update your model to include an intermediate population, that develops mid-river. Allow migration between all three populations at different rates, based on the up vs. downriver and distance between them. Woolly Mammoth on Wrangel Island There are two populations of woolly mammoths - a large (n = 4500) population on the mainland and a small (n = 450) population on Wrangel Island. For some generations, bidirectional migration is allowed between the populations via an ice bridge. However, after some time, the ice bridge melts, and migration ends. First, simulate migration between the two populations. Then, track the allele frequency (using code from week 2) of a slightly deleterious allele in each population. How often does it fix in the larger, mainland population? How often does it fix in the smaller, island population? You can also use the following block of code to look at the mean fitness of both populations, if you want to observe how removing the ice bridge impacts fitness of your populations: 10000 early() { p1MeanFitness = mean(p1.cachedFitness(NULL)); p2MeanFitness = mean(p2.cachedFitness(NULL)); print(paste(p1MeanFitness, p2MeanFitness, sep= &quot; &quot;)); } Here’s a paper if you’re curious about this (you can just glance at the abstract): https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1006601. European Mice There are two distinct populations of mice in western Europe. A hybrid zone (here, a third population) forms based on individuals from both of the original populations. This third population has some very limited migration back to the original two populations. (This represents an example of limited backflow - meaning the two populations can hybridize and reproduce, but the hybrids don’t usually reproduce with the original individuals. Rather, they stay among themselves.) Hint: in SLiM you can’t use the same syntax to create an empty population. Try starting the hybrid population with just one individual. "],["plotting-in-r.html", "3.15 Plotting in R", " 3.15 Plotting in R 3.15.1 Visualizing Simulations So far in class and for homework we’ve simulated a variety of evolutionary dynamics and visualized their results with built-in plots in SLiM. In some cases, the things you’ll simulate will be best visualized by custom plots, which we’ll start writing in R. This introduction to R will be useful as you move into futher coding projects as the fundamentals of plotting will remain the same. 3.15.2 R basics A few coding terms: - function: code that is used to execute something (e.g., the print() function is the same in R as it is in SLiM) - package: a set of functions that already exist and can be loaded into your workspace - comment: in R, you indicate a comment with the pound (or hashtag) # - script: a file (typically with the suffix .R) that contains your R code 3.15.3 Reading data in to R To start your plot, you’ll need to have your data in your R workspace. Recall that you wrote the output of your allele frequency simulations to file; you created 3 different files, each exploring a unqiue set of parameters, so you could compare the dynamics resulting from changing those parameters (e.g., population size, selection coefficient). You can read those files (or any other file you’d like to investigate in R). # read in the data from your first allele frequency simulation af1 &lt;- read.csv(&quot;~/slim/AF_trial1.csv&quot;) In the above example, you’re using the read.csv function (which is built in to R) to save your allele frequency file with the variable name af1. If you did head(af1) or print(af1) you would see the contents of this file. We use the read.csv function becase your file was saved in csv (comma separated values) format, as you can see from the suffix of your filename. 3.15.4 Using published packages We will plot with the package ggplot2. This library offers a set of functions designed for visualizations in R. You can read more about it here. When using a new package, you’ll first need to install it into your workspace’s library. Each time you write a script you will load any package you wish to use from your library. # the first time you&#39;re using ggplot (or any package), install it install.packages(&quot;ggplot2&quot;) # each time you want to use the package, load it in your script library(ggplot2) Note that the install.packages() function requires its argument to be in quotes (a string) but the library() function accepts a variable name without quotes. 3.15.5 Psuedocode It is often helpful to outline in plain language (not code) what you intend to do in your script. This allows you to clearly outline your plans and design your plots without getting bogged down by the syntax of your code. Comments (which begin with the # in R) are a useful way to do this. 3.15.6 ggplot2 basics The main function in ggplot2 is very simply ggplot(). It then takes the major arguments data (which will be the data you read in from your file, i.e., af1 in the above example) and aes(). Aes() is short for aesthetics; it usually includes the data column needed for the x axis and the data column needed for the y axis. It can also include the data column used for the color. Additional information is then applied to that function via +. To plot the frequency trajectory of an allele in a population, we’ll use a line plot; this is added through the geom_line() function. We’ll also specify which data column to label the information by via the labs() function. Check out the ggplot2 website above for examples of additional information and customization you can apply to your plots. You might consider theme_classic() or setting a limit on the x axis via xlim(), in addition to others. The syntax would therefore be something like: # create your plot ggplot(data = my_data, aes(x = column_for_x_axis, y = column_for_y_axis, color = as.factor(column_to_base_colors_on))) + geom_line() + # create a line plot theme_classic() + # apply a theme labs(colour=&quot;Column that color is based on&quot;) # indicate that the color is based on whatever column you chose 3.15.7 Saving a plot When you’re done with your plot, you can save it by going to the file menu and exporting it as you would any other file. Or you can do so in R code with the function ggsave(): # assign your plot to an object plot1 &lt;- ggplot(data = my_data, aes(x = column_for_x_axis, y = column_for_y_axis, color = as.factor(column_to_base_colors_on))) + geom_line() + # create a line plot theme_classic() + # apply a theme labs(colour=&quot;Column that color is based on&quot;) ggsave(plot1, &quot;filepath/filename.pdf&quot;) The function ggsave() is built-in to the ggplot2 package. It expects two arguments: the variable name of the plot you’re interested in printing, and then the name of the file (along with full file path) you’d like to save the image to. 3.15.8 Assignment Work through the ggplot2 tutorial. Plot the frequency trajectory of one allele in the population. 2a. Write psuedocode for each step (think about the x axis, the y axis, what style (e.g., scatterplot, line plot) would best represent your data and answer your question). 2b. Fill in the name of the data as well as the aesthetics (x and y). Remember that you’re plotting allele frequency, which is a measure of the number of a given allele in the population divided by the number of possible instances at that site. For example, if you have 10 copies of the allele A at a given position and there are 20 individuals in your population, there are 40 possible instances at that site (humans are diploid - two copies of each chromosome), so the frequency of the A allele is 10 / (20 * 2) = 0.25. Update your code to include three additional allele frequency trajectories on a single plot. To do so, merge the data from the four allele frequency files into a single data structure. 3a. Add any additional psuedocode necessary. 3b. Consider using the rbind() function to combine the information from the four trials into a single data structure. 3c. Add an aesthetic to color each allele frequency trajectory by the value in the Trial column. Consider using the as.factor() function to ensure each trial is treated as a discrete variable and plotted in a distinct color. 3d. Limit the x axis to include only values from 0 to 4000. 3e. Explore various themes available in ggplot2 and apply one to your plot. Email your code and the resulting pdf files for the images. "],["variable-population-size.html", "3.16 Variable Population Size", " 3.16 Variable Population Size This is an optional module covering an interesting topic that we won’t have time to get into in the main course. The primary measure of fitness is the number of viable offspring that an organism is able to have. Consequently, as the fitness of individuals within a population changes, the size of the population may change as well. Population size can also change as the result of external factors, such as natural disasters, famine, disease, etc. SLiM allows for pretty easy manipulation of population size. 3.16.1 Changing Population Size After we create a subpopulation using sim.addSubpop(), we can modify the population using the setSubpopulationSize() method, run as such: &lt;population name&gt;.setSubpopulationSize(&lt;new size&gt;). For example, the following lines create a subpopulation and then cause an abrupt crash in population size: 1 early() { sim.addSubpop(&quot;p1&quot;, 3000); } 150 early() { p1.setSubpopulationSize(100); } 3.16.2 Exercise The strength of genetic drift (random fluctuations of allele frequency from generation to generation) is related to the population size. Initialize a simulation with a neutral mutation and after a set number of generations, sharply decrease the population size. Observe the rate at which the allele frequencies change from generation to generation before and after the population size change. Slowing the simulation down will make this easier to observe (done using the sliding bar beneath the play button). 3.16.3 Multiple size changes The code above changes the population size once. What if we want to grow/shrink the population at a continuous rate? This takes only a couple small changes to the code above: 1 early() { sim.addSubpop(&quot;p1&quot;, 3000); } 150:170 early() { currentSize = p1.individualCount; newSize = asInteger(currentSize * 0.97); p1.setSubpopulationSize(newSize); } Here, we’ve done the following: Rather than occurring in one generation, the event now occurs from generations 150:170 We get the current population size using the syntax p1.individualCount We calculate the new population size by multiplying by 0.97, and then converting to an integer using asInteger() We set the population size to the new calculated size . 3.16.4 Maximum/Minimum Population Size In the example above, our population grows or shrinks at a constant rate, indefinitely. In reality, the possible size of a population will have an upper bound. We can impose this limit by adding an if statement, as done below. The crucial line here is: if (p1.individualCount &lt; 2000) - the block following this line is only evaluated if the condition is true. That is, once your population hits a size of 2000, it stops growing. 1 early() { sim.addSubpop(&quot;p1&quot;, 500); } 150: early() { if (p1.individualCount &lt; 2000) { currentSize = p1.individualCount; newSize = asInteger(currentSize * 1.05); p1.setSubpopulationSize(newSize); } } 3.16.5 Exercise The above code is used to create a simulation where the population grows until it hits a maximum population size. Try modifying it to create a population that shrinks until it hits a minimum. 3.16.6 Growth rate dependent on fitness One small change is necessary to make the population size dependent on mean fitness. 1 early() { sim.addSubpop(&quot;p1&quot;, 500); } 2: early() { if (p1.individualCount &lt; 2000 &amp; p1.individualCount &gt; 1) { currentSize = p1.individualCount; meanFitness = mean(p1.cachedFitness(NULL)); newSize = asInteger(currentSize * meanFitness); p1.setSubpopulationSize(newSize); } } First, we have modified our if statement to have the following condition: p1.individualCount &lt; 2000 &amp; p1.individualCount &gt; 1 - that is, we track both a maximum and a minimum population size. The &amp; in the statement indicates that both conditions need to be true for the code block to be evaluated. The other relevant lines are: meanFitness = mean(p1.cachedFitness(NULL)); newSize = asInteger(currentSize * meanFitness); The first line gets the mean fitness of our population (don’t worry about the exact syntax of how this is calculated - a bit beyond the scope of our course). The second line changes the calculation of the new population size dependent on the mean fitness. Recall that a fitness value of 1.0 is neutral - that is the population size doesn’t change. If mean fitness is &gt;1, the population size grows; if mean fitness is &lt;1, the population size shrinks. 3.16.7 Exercise Create a simulation with multiple mutation types - some neutral, some beneficial, some deleterious. Use the above code block to create a simulation where the population size grows or shrinks depending on mean fitness. "],["different-conditions-for-different-populations.html", "3.17 Different Conditions for Different Populations", " 3.17 Different Conditions for Different Populations Now that we have developed models with multiple populations, we can create different conditions for our populations. One of the simplest ways to do this is to change the fitness effect of a mutation in a population-specific manner. Let’s model this by simulating local adaptation - that is to say, when an allele that is beneficial in one specific environment while being neutral in all others. We can start by initializing a simple two population model, with a common neutral mutation and a deleterious allele type that isn’t yet used. Let’s set a relatively low (1%) migration rate between both populations. initialize() { initializeMutationRate(1e-7); initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); // m1 mutation type: neutral initializeMutationType(&quot;m2&quot;, 0.5, &quot;f&quot;, -0.03); // m2 mutation type: deleterious m2.convertToSubstitution = F; initializeGenomicElementType(&quot;g1&quot;, m1, 1.0); // uniform chromosome of length 100 kb with uniform recombination initializeGenomicElement(g1, 0, 9999); initializeRecombinationRate(1e-8); } // create two populations of 500 individuals // 1% migration rate in both directions 1 early() { sim.addSubpop(&quot;p1&quot;, 500); sim.addSubpop(&quot;p2&quot;, 500); p1.setMigrationRates(p2, 0.01); p2.setMigrationRates(p1, 0.01); } Now, let’s add deleterious m2 mutations into p1 at a frequency of 5%. 400 late() { p1_size = size(p1.genomes); // Count how many chromosomes we have initial_freq = asInteger(p1_size * 0.05); // Find 5% of total number of chromosomes target = sample(p1.genomes, initial_freq); // Randomly sample 5% of chromosomes target.addNewDrawnMutation(m2, 1000); // Add new mutation } If you run this simulation a few times, you’ll see that m2 will always disappear. We can create population specific effects for our mutation using the mutationEffect() function. For example, we can add in the following line of code: mutationEffect(m2, p2) { return 1.1; } Let’s break this down: Because no generation/tick numbers are provided, this mutationEffect will persist until the end of the simulation. If we wanted to temporarily modify the mutation effect, we could write something like: 400:600 mutationEffect(m2, p2) { return 1.1; } (m2, p2) indicates that we are modifying the effect of m2 in the population p2. We could have provided the argument (m2) to modify the effect of m2 across all populations. return 1.1; indicates how we want to modify our mutation effect. Two things happen here. 1. The previous mutation effect of the mutation is ignored. Specifically, the previous value of -0.03 is forgotten. 2. To calculate our new fitness, we multiply the individual’s fitness by the value provided here. That is, our fitness is calculated as 1.1 * current fitness. In other words, to make a mutation neutral, we would write return 1.0;. To make it deleterious, we would return a value lower than 1. Another way of writing this statement is by directly modifying the fitness effect of our mutation: mutationEffect(m2, p2) { return effect + 0.05; }. This takes our fitness value, -0.03, and updates it to be -0.03 + 0.05, or 0.02. Putting this all together, along with a line that prints out our allele count for m2 in both populations; initialize() { initializeMutationRate(1e-7); initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); // m1 mutation type: neutral initializeMutationType(&quot;m2&quot;, 0.5, &quot;f&quot;, -0.03); // m2 mutation type: deleterious m2.convertToSubstitution = F; initializeGenomicElementType(&quot;g1&quot;, m1, 1.0); // uniform chromosome of length 100 kb with uniform recombination initializeGenomicElement(g1, 0, 9999); initializeRecombinationRate(1e-8); } // create two populations of 500 individuals // 1% migration rate in both directions 1 early() { sim.addSubpop(&quot;p1&quot;, 500); sim.addSubpop(&quot;p2&quot;, 500); p1.setMigrationRates(p2, 0.01); p2.setMigrationRates(p1, 0.01); } 400 late() { p1_size = size(p1.genomes); // Count how many chromosomes we have initial_freq = asInteger(p1_size * 0.05); // Find 5% of total number of chromosomes target = sample(p1.genomes, initial_freq); // Randomly sample 5% of chromosomes target.addNewDrawnMutation(m2, 1000); // Add new mutation } // modify our mutation to be beneficial in p2 mutationEffect(m2, p2) { return effect + 0.1; } // print out m2 count in both populations 400:1000 late() { print(c(sum(p1.genomes.countOfMutationsOfType(m2)), sum(p2.genomes.countOfMutationsOfType(m2)))); } "],["code-from-week-5.html", "3.18 Code from Week 5", " 3.18 Code from Week 5 Here is the final simulation developed in class: // set up a simple neutral simulation initialize() { initializeMutationRate(1e-7); // m1 mutation type: neutral initializeMutationType(&quot;m1&quot;, 0.5, &quot;f&quot;, 0.0); initializeMutationType(&quot;m2&quot;, 0.5, &quot;f&quot;, -0.03); m2.convertToSubstitution=F; // g1 genomic element type: uses m1 for all mutations initializeGenomicElementType(&quot;g1&quot;, m1, 1.0); // uniform chromosome of length 100 kb with uniform recombination initializeGenomicElement(g1, 0, 99999); initializeRecombinationRate(1e-8); } // create a population of 500 individuals 1 early() { sim.addSubpop(&quot;p1&quot;, 5000); } 299 late() { p1_size = size(p1.genomes); // Count how many chromosomes we have initial_freq = asInteger(p1_size * 0.05); // Find 5% of total number of chromosomes target = sample(p1.genomes, initial_freq); // Randomly sample 5% of chromosomes target.addNewDrawnMutation(m2, 1000); // Add new mutation } 300 early() { sim.addSubpopSplit(&quot;p2&quot;, 5000, p1); p2.setMigrationRates(p1, 0.0); p1.setMigrationRates(p2, 0.0); } 400:700 mutationEffect(m2, p2) { return effect + 0.1; } 300:2000 late() { print(c(sum(p1.genomes.countOfMutationsOfType(m2)), sum(p2.genomes.countOfMutationsOfType(m2)))); } "],["week-5-assignment.html", "3.19 Week 5 Assignment", " 3.19 Week 5 Assignment 3.19.1 Splitting Populations We can put together many of the simulation techniques we’ve learned so far by creating a model for early human evolution, as presented in Gravel et al. 2011: https://www.pnas.org/doi/full/10.1073/pnas.1019276108. To build this simulation please… Initialize the necessary parameters in your initialize() statement Create an ancestral African population (with about 7,000 individuals) and allow for a burn-in period of approximately 73,000 generations Split the population at about the 77,000th generation, creating a Eurasian population. Allow migration between the two Split the Eurasian population into two at about the 78,000th generation, creating a European and an Asian population. allow migration between all three populations Set up exponential growth in the European and Asian populations for the following 1000 generations (see the hint below for this code) Please keep in mind a few things for this simulation. First, the suggested population sizes are the effective population. Second, we’re suggesting round numbers that will broadly represent the model presented in Gravel 2011; for more exact numbers, see the SLiM manual on page 135. Please submit your SLiM code (ideally exported as a .txt file) for this simulation. For exponential growth, you can do something like the below. Here we’ve decided to start the exponential growth in the 78000th generation and continue it until the 79000th generation. We’ve started the p2 population as 1000 individuals. You can change these values if you like. However, we do suggest using the 1 + 0.003789 value for the time measurement. // do this at the start of each generation from 78,000 to 79,000 78000:79000 early() { // get the count of each generation, starting at your current start of 78000 time = sim.cycle - 78000; // sim.cycle counts the units of time (check the manual for more details) p2_size = round(1000 * (1 + 0.003789)^time); // fill in similar syntax for p3_size p2.setSubpopulationSize(asInteger(p2_size)); // fill in similar syntax for p3 } 3.19.2 Local Adaptation Sometimes a population effectively splits into two populations and experiences some force (e.g., migration) such that the resulting subpopulations are subject to different selective pressures. For example, turtles on the Galapagos Islands have extremely different traits (“phenotypes”), likely as a consequence of their local environments. Create a simulation that starts with one population of turtles, then has the population split. Imagine that one population is on an area of the island with low-growth vegetation, such that a short neck is sufficient to eat and survive; but the other population is on an area of the island with higher-growth vegetation, such that the short neck is detrimental to survival. A longer neck is survivable in the low-growth vegetation population, but those turtles do have reduced fitness relative to the shorter neck individuals (e.g., maybe their necks get tired from leaning down to get the vegetation and need to rest more). In both populations, track the mutation for shorter neck and longer neck. What do you notice? Modify your simulation to allow low rates of migration between the two populations. Any difference in the allele rates in either population? "],["papers-of-interest.html", "4 Papers of Interest", " 4 Papers of Interest In this section, we will curate a list of papers, both recent and historical, that are relevant to the topics discussed in class. 4.0.1 Week 3 - Multiple Populations Rogers &amp; Slatkin 2017 - Genomic differences between Woolly mammoth populations Arai et al. 2020 - Inferring and analyzing migration among stickleback fish populations 4.0.2 Week 2 - Selection and Sweeps Tishkoff et al, 2007 - Lactase persistence evolved independently in Europe and Africa. This paper uses sequencing data from hundreds of African individuals to map the evolution of LP in Africa. Evershed et al, 2022 - A recent paper looking at how LP originated in Europe. Using a combination of genomic and archaeological methods, this paper shows how milk was used in Europe for thousands of years prior to the rise of LP, and supports the role of evolutionary pressures such as famine and disease in the rise of European LP. Gould and Lewontin, 1979 - A famous and controversial paper. This paper is a major part of the debate about the role of adaptation in natural selection, and had a huge impact on how scientists think about adaptation and evolutionary storytelling. The extent that adaptation shapes organismal form and function is still an open question. 4.0.3 Week 3 - Multiple Populations Yan et al, 2021 - A recent work leveraging simulation to identify a variant with a strong selective coefficient in some populations (s = 0.6 - one of the highest examples in humans!). This variant was also found to be introgressed from Neandertals. "],["lecture-slides.html", "5 Lecture Slides", " 5 Lecture Slides Week 1 Week 2 Week 3 "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Content Author Andrew Bortvin Content Author Sara Carioscia Website Template Jeff Leek &amp; The Johns Hopkins Data Science Lab Design Inspiration Stephanie Yan &amp; Ali Madooei &amp; JHU Data Structures   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-11-28 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.2) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## png 0.1-8 2022-11-29 [1] CRAN (R 4.0.2) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## Rcpp 1.0.10 2023-01-22 [1] CRAN (R 4.0.2) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## reticulate 1.28 2023-01-27 [1] CRAN (R 4.0.2) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## rstudioapi 0.11 2020-02-07 [1] RSPM (R 4.0.0) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["references.html", "6 References", " 6 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
